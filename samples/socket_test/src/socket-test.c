/* socket-test.c - Networking UDP socket client */

/*
 * Copyright (c) 2022 RedNodeLabs UG.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * The socket-test application is acting as a client that is run in Zephyr OS,
 * and the server is run in the host acting as a server.
 */

#include <logging/log.h>
LOG_MODULE_REGISTER(net_socket_test_sample, LOG_LEVEL_DBG);

#include <zephyr.h>
#include <errno.h>
#include <stdio.h>

#include <syscalls/rand32.h>
#include <net/socket.h>
#include <net/net_mgmt.h>
#include <net/net_event.h>
#include <net/net_conn_mgr.h>
#include <net/ieee802154_radio.h>

#ifdef CONFIG_REDNODEBUS
#include "rnb_utils.h"
#endif /* CONFIG_REDNODEBUS */

#include "common.h"

#define INVALID_SOCK (-1)

#define EVENT_MASK (NET_EVENT_L4_CONNECTED | \
		    NET_EVENT_L4_DISCONNECTED)

#define MTU_SIZE 1280

static uint8_t rnb_role;

void rnb_utils_handle_new_state(const struct rednodebus_user_event_params_state *state)
{
	rnb_role = state->role;
}

/* Generated by http://www.lipsum.com/
 * 2 paragraphs, 179 words, 1160 bytes of Lorem Ipsum
 */
char lorem_ipsum[] =
    "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Quisque "
    "sodales lorem lorem, sed congue enim vehicula a. Sed finibus diam sed "
    "odio ultrices pharetra. Nullam dictum arcu ultricies turpis congue, "
    "vel venenatis turpis venenatis. Nam tempus arcu eros, ac congue libero "
    "tristique congue. Proin velit lectus, euismod sit amet quam in, "
    "maximus condimentum urna. Cras vel erat luctus, mattis orci ut, varius "
    "urna. Nam eu lobortis velit."
    "\n"
    "Nullam sit amet diam vel odio sodales cursus vehicula eu arcu. Proin "
    "fringilla, enim nec consectetur mollis, lorem orci interdum nisi, "
    "vitae suscipit nisi mauris eu mi. Proin diam enim, mollis ac rhoncus "
    "vitae, placerat et eros. Suspendisse convallis, ipsum nec rhoncus "
    "aliquam, ex augue ultrices nisl, id aliquet mi diam quis ante. "
    "Pellentesque venenatis ornare ultrices. Quisque et porttitor lectus. "
    "Ut venenatis nunc et urna imperdiet porttitor non laoreet massa. Donec "
    "eleifend eros in mi sagittis egestas. Sed et mi nunc. Nunc vulputate, "
    "mauris non ullamcorper viverra, lorem nulla vulputate diam, et congue "
    "dui velit non erat. Duis interdum leo et ipsum tempor consequat. In "
    "faucibus enim quis purus vulputate nullam."
    "\n";

const int ipsum_len = sizeof(lorem_ipsum) - 1;

#if !defined(CONFIG_USE_REDNODEBUS_USER_PAYLOAD_ONLY)
struct configs conf = {
    .ipv6 = {
	.proto = "IPv6",
	.udp.sock = INVALID_SOCK},
};

static struct k_thread udp_thread;
static K_KERNEL_STACK_MEMBER(udp_stack, 800);
#endif

#if defined(CONFIG_USE_REDNODEBUS_USER_PAYLOAD)
struct configs_rnb conf_rnb = {
	.rnb = {
		.proto = "RNB",
		.rnb_user_payload.mtu = REDNODEBUS_USER_PAYLOAD_MAX_LENGTH,
	}
};

static struct k_thread rnb_thread;
static K_KERNEL_STACK_MEMBER(rnb_stack, 800);
#endif

#if !defined(CONFIG_USE_REDNODEBUS_USER_PAYLOAD_ONLY)
static void init_app(void)
{
	conf.ipv6.udp.mtu = MTU_SIZE;

#if defined(CONFIG_REDNODEBUS)
	uint64_t euid = 0;
	rnb_utils_get_euid(&euid);

	sprintf(lorem_ipsum, "%04X%04X", (uint32_t)(euid >> 32), (uint32_t)euid);

	int session_rand = sys_rand32_get();
	memcpy(&lorem_ipsum[UID_CHARS], &session_rand, sizeof(session_rand));
#endif
}

static int start_client(void)
{
	int iterations = 0;
	int i = 0;
 	int ret, rc;
	static int packets_sent = 0;

	while (iterations == 0 || i < iterations)
	{
		ret = start_udp();

		while (ret == 0)
		{
			memcpy(&lorem_ipsum[UID_CHARS + SESSION_RAND_CHARS], &packets_sent, sizeof(packets_sent));
			rc = send_udp_data(&conf.ipv6);
			if(rc < 0)
			{
				LOG_ERR("Failed to send data");
			}
			else
			{
				packets_sent++;
			}

			if (iterations > 0)
			{
				i++;
				if (i >= iterations)
				{
					break;
				}
			}
			if (rnb_role == REDNODEBUS_USER_ROLE_TAG)
			{
				k_sleep(K_MSEC(UDP_TRANSMISSION_PERIOD_TAG_MSEC));
			}
			else
			{
				k_sleep(K_MSEC(UDP_TRANSMISSION_PERIOD_MSEC));
			}
		}
		stop_udp();
	}
	return ret;
}

static void socket_test_udp_thread(void *arg1, void *arg2, void *arg3)
{
	init_app();

	exit(start_client());
}
#endif

#if defined(CONFIG_USE_REDNODEBUS_USER_PAYLOAD)
static void init_app_rnb(void)
{
#if defined(CONFIG_REDNODEBUS)
	uint64_t euid = 0;
	rnb_utils_get_euid(&euid);

	sprintf(lorem_ipsum, "%04X%04X", (uint32_t)(euid >> 32), (uint32_t)euid);

	int session_rand = sys_rand32_get();
	memcpy(&lorem_ipsum[UID_CHARS], &session_rand, sizeof(session_rand));
#endif
}

static int start_client_rnb(void)
{
	int iterations = 0;
	int i = 0;
	int ret, rc;
	static int packets_sent = 0;

	while (iterations == 0 || i < iterations)
	{
		ret = start_rnb_user_payload();

		while (ret == 0)
		{
			memcpy(&lorem_ipsum[UID_CHARS + SESSION_RAND_CHARS], &packets_sent, sizeof(packets_sent));
			conf_rnb.rnb.rnb_user_payload.transmitting = UDP_TRANSMISSION_BYTES % ipsum_len;
			memcpy(&conf_rnb.rnb.rnb_user_payload.rnb_user_payload_params.user_payload, lorem_ipsum, conf_rnb.rnb.rnb_user_payload.transmitting);
			rc = send_rnb_data(&conf_rnb.rnb);
			if(rc < 0)
			{
				LOG_ERR("Failed to send data");
			}
			else
			{
				packets_sent++;
			}

			if (iterations > 0)
			{
				i++;
				if (i >= iterations)
				{
					break;
				}
			}
			if (rnb_role == REDNODEBUS_USER_ROLE_TAG)
			{
				k_sleep(K_MSEC(UDP_TRANSMISSION_PERIOD_TAG_MSEC));
			}
			else
			{
				k_sleep(K_MSEC(UDP_TRANSMISSION_PERIOD_MSEC));
			}
		}
		stop_rnb_user_payload();
	}
	return ret;
}

static void socket_test_rnb_thread(void *arg1, void *arg2, void *arg3)
{
	init_app_rnb();

	exit(start_client_rnb());
}
#endif

void main(void)
{
#ifdef CONFIG_REDNODEBUS
	init_rnb();

	while (!is_rnb_connected())
	{
		k_sleep(K_MSEC(1000));
	}
#endif /* CONFIG_REDNODEBUS */

#if !defined(CONFIG_USE_REDNODEBUS_USER_PAYLOAD_ONLY)
	k_thread_create(&udp_thread,
			udp_stack,
			K_THREAD_STACK_SIZEOF(udp_stack),
			socket_test_udp_thread,
			NULL,
			NULL,
			NULL,
			K_PRIO_PREEMPT(7),
			0,
			K_NO_WAIT);
#endif
#if defined(CONFIG_USE_REDNODEBUS_USER_PAYLOAD)
	k_thread_create(&rnb_thread,
			rnb_stack,
			K_THREAD_STACK_SIZEOF(rnb_stack),
			socket_test_rnb_thread,
			NULL,
			NULL,
			NULL,
			K_PRIO_PREEMPT(7),
			0,
			K_NO_WAIT);
#endif
}
