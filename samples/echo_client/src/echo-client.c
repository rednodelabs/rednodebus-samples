/* echo-client.c - Networking echo client */

/*
 * Copyright (c) 2017 Intel Corporation.
 * Copyright (c) 2018 Nordic Semiconductor ASA.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * The echo-client application is acting as a client that is run in Zephyr OS,
 * and echo-server is run in the host acting as a server. The client will send
 * either unicast or multicast packets to the server which will reply the packet
 * back to the originator.
 *
 * In this sample application we create four threads that start to send data.
 * This might not be what you want to do in your app so caveat emptor.
 */

#include <logging/log.h>
LOG_MODULE_REGISTER(net_echo_client_sample, LOG_LEVEL_DBG);

#include <zephyr.h>
#include <errno.h>
#include <stdio.h>

#include <net/socket.h>

#include <net/net_mgmt.h>
#include <net/net_event.h>
#include <net/net_conn_mgr.h>
#ifdef CONFIG_REDNODEBUS
#include <net/ieee802154_radio.h>
#include "rnb_utils.h"
#endif /* CONFIG_REDNODEBUS */

#include "common.h"

#define APP_BANNER "Run echo client"

#define INVALID_SOCK (-1)

#define EVENT_MASK (NET_EVENT_L4_CONNECTED | \
		    NET_EVENT_L4_DISCONNECTED)

#define MTU_SIZE 1280

/* Generated by http://www.lipsum.com/
 * 2 paragraphs, 179 words, 1160 bytes of Lorem Ipsum
 */
const char lorem_ipsum[] =
	"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Quisque "
	"sodales lorem lorem, sed congue enim vehicula a. Sed finibus diam sed "
	"odio ultrices pharetra. Nullam dictum arcu ultricies turpis congue, "
	"vel venenatis turpis venenatis. Nam tempus arcu eros, ac congue libero "
	"tristique congue. Proin velit lectus, euismod sit amet quam in, "
	"maximus condimentum urna. Cras vel erat luctus, mattis orci ut, varius "
	"urna. Nam eu lobortis velit."
	"\n"
	"Nullam sit amet diam vel odio sodales cursus vehicula eu arcu. Proin "
	"fringilla, enim nec consectetur mollis, lorem orci interdum nisi, "
	"vitae suscipit nisi mauris eu mi. Proin diam enim, mollis ac rhoncus "
	"vitae, placerat et eros. Suspendisse convallis, ipsum nec rhoncus "
	"aliquam, ex augue ultrices nisl, id aliquet mi diam quis ante. "
	"Pellentesque venenatis ornare ultrices. Quisque et porttitor lectus. "
	"Ut venenatis nunc et urna imperdiet porttitor non laoreet massa. Donec "
	"eleifend eros in mi sagittis egestas. Sed et mi nunc. Nunc vulputate, "
	"mauris non ullamcorper viverra, lorem nulla vulputate diam, et congue "
	"dui velit non erat. Duis interdum leo et ipsum tempor consequat. In "
	"faucibus enim quis purus vulputate nullam."
	"\n";

const int ipsum_len = sizeof(lorem_ipsum) - 1;

#if !defined(CONFIG_USE_REDNODEBUS_USER_PAYLOAD_ONLY)
struct configs conf = {
	.ipv6 = {
		.proto = "IPv6",
		.udp.sock = INVALID_SOCK,
		.tcp.sock = INVALID_SOCK,
	}
};

static struct pollfd fds[4];
static int nfds;

static bool connected;
K_SEM_DEFINE(run_app, 0, 1);

#if defined(CONFIG_NET_CONNECTION_MANAGER)
static struct net_mgmt_event_callback mgmt_cb;
#endif

static struct k_thread udp_thread;
static K_KERNEL_STACK_MEMBER(udp_stack, 800);
#endif

#if defined(CONFIG_USE_REDNODEBUS_USER_PAYLOAD)
struct configs_rnb conf_rnb = {
	.rnb = {
		.proto = "RNB",
		.rnb_user_payload.mtu = REDNODEBUS_USER_PAYLOAD_MAX_LENGTH,
	}
};

static struct k_thread rnb_thread;
static K_KERNEL_STACK_MEMBER(rnb_stack, 800);
#endif

#if !defined(CONFIG_USE_REDNODEBUS_USER_PAYLOAD_ONLY)
static void prepare_fds(void)
{
	if (conf.ipv6.udp.sock >= 0) {
		fds[nfds].fd = conf.ipv6.udp.sock;
		fds[nfds].events = POLLIN;
		nfds++;
	}

	if (conf.ipv6.tcp.sock >= 0) {
		fds[nfds].fd = conf.ipv6.tcp.sock;
		fds[nfds].events = POLLIN;
		nfds++;
	}
}

static void wait(void)
{
	/* Wait for event on any socket used. Once event occurs,
	 * we'll check them all.
	 */
	if (poll(fds, nfds, -1) < 0) {
		LOG_ERR("Error in poll:%d", errno);
	}
}

static int start(void)
{
	int ret;

	LOG_INF("Starting...");

	if (IS_ENABLED(CONFIG_NET_UDP)) {
		ret = start_udp();
		if (ret < 0) {
			return ret;
		}
	}

	prepare_fds();

	return 0;
}

static int run(void)
{
	int ret;

	wait();

	if (IS_ENABLED(CONFIG_NET_UDP)) {
		ret = process_udp();
		if (ret < 0) {
			return ret;
		}
	}

	return 0;
}

static void stop(void)
{
	LOG_INF("Stopping...");

	if (IS_ENABLED(CONFIG_NET_UDP)) {
		stop_udp();
	}
}

#if defined(CONFIG_NET_CONNECTION_MANAGER)
static void event_handler(struct net_mgmt_event_callback *cb,
			  uint32_t mgmt_event, struct net_if *iface)
{
	if ((mgmt_event & EVENT_MASK) != mgmt_event) {
		return;
	}

	if (mgmt_event == NET_EVENT_L4_CONNECTED) {
		LOG_INF("Network connected");

		connected = true;
		conf.ipv6.udp.mtu = net_if_get_mtu(iface);
		k_sem_give(&run_app);

		return;
	}

	if (mgmt_event == NET_EVENT_L4_DISCONNECTED) {
		LOG_INF("Network disconnected");

		connected = false;
		k_sem_reset(&run_app);

		return;
	}
}
#endif

static void init_app(void)
{
	LOG_INF(APP_BANNER);

	if (IS_ENABLED(CONFIG_NET_CONNECTION_MANAGER)) {
		net_mgmt_init_event_callback(&mgmt_cb,
					     event_handler, EVENT_MASK);
		net_mgmt_add_event_callback(&mgmt_cb);

		net_conn_mgr_resend_status();
	}

	init_vlan();
}

static int start_client(void)
{
	int iterations = 0;
	int i = 0;
	int ret = 0;

	while (iterations == 0 || i < iterations) {
		/* Wait for the connection. */
		k_sem_take(&run_app, K_FOREVER);

		ret = start();

		while (connected && (ret == 0))
 		{

			ret = run();

			if (iterations > 0) {
				i++;
				if (i >= iterations) {
					break;
				}
			}
		}

		stop();
	}

	return ret;
}

static void echo_client_udp_thread(void *arg1, void *arg2, void *arg3)
{
	init_app();

	if (!IS_ENABLED(CONFIG_NET_CONNECTION_MANAGER)) {
		conf.ipv6.udp.mtu = MTU_SIZE;

		connected = true;

		/* If the config library has not been configured to start the
		 * app only after we have a connection, then we can start
		 * it right away.
		 */
		k_sem_give(&run_app);
	}

	exit(start_client());
}
#endif

#if defined(CONFIG_USE_REDNODEBUS_USER_PAYLOAD)
static void wait_rnb(void)
{
	wait_rnb_user_payload_reply();
}

static int start_rnb(void)
{
	int ret;

	LOG_INF("Starting RedNodeBus user payload...");

	ret = start_rnb_user_payload();
	if (ret < 0) {
		return ret;
	}

	return 0;
}

static int run_rnb(void)
{
	int ret;

	wait_rnb();

	ret = process_rnb_user_payload();
	if (ret < 0) {
		return ret;
	}

	return 0;
}

static void stop_rnb(void)
{
	LOG_INF("Stopping RedNodeBus user payload...");

	stop_rnb_user_payload();
}

static void init_app_rnb(void)
{

}

static int start_client_rnb(void)
{
	int iterations = 0;
	int i = 0;
	int ret = 0;

	while (iterations == 0 || i < iterations) {
		ret = start_rnb();

		while (ret == 0)
 		{
			ret = run_rnb();

			if (iterations > 0) {
				i++;
				if (i >= iterations) {
					break;
				}
			}
		}

		stop_rnb();
	}

	return ret;
}

static void echo_client_rnb_thread(void *arg1, void *arg2, void *arg3)
{
	init_app_rnb();

	exit(start_client_rnb());
}
#endif

void main(void)
{
#ifdef CONFIG_REDNODEBUS
	init_rnb();

	while (!is_rnb_connected())
	{
		k_sleep(K_MSEC(1000));
	}
#endif /* CONFIG_REDNODEBUS */

#if !defined(CONFIG_USE_REDNODEBUS_USER_PAYLOAD_ONLY)
	k_thread_create(&udp_thread,
			udp_stack,
			K_THREAD_STACK_SIZEOF(udp_stack),
			echo_client_udp_thread,
			NULL,
			NULL,
			NULL,
			K_PRIO_PREEMPT(7),
			0,
			K_NO_WAIT);
#endif
#if defined(CONFIG_USE_REDNODEBUS_USER_PAYLOAD)
	k_thread_create(&rnb_thread,
			rnb_stack,
			K_THREAD_STACK_SIZEOF(rnb_stack),
			echo_client_rnb_thread,
			NULL,
			NULL,
			NULL,
			K_PRIO_PREEMPT(7),
			0,
			K_NO_WAIT);
#endif
}
